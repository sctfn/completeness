#!/usr/bin/env python3

"""completeness - prove tautologies for Metamath

-Scott Fenton <sctfen@gmail.com>"""

import sys
import collections

USE_ABRVS = True

### Proof classes ###

class Proof:
    """Base class to represent a proof"""

    def __init__(self, subpfs, wffs):
        self.subpfs = subpfs
        self.wffs = wffs
        self.hyps = self._hypsof()
        self.result = self._result(*wffs)

    def _hypsof(self):
        """Return the hypotheses used in self"""

        return {h for sp in self.subpfs for h in sp.hyps}

    def __len__(self):
        """Return the length of the proof generated by self"""

        return 1 + sum(map(len,self.subpfs))

    def __str__(self):
        res = self.mm.format(*[w.as_syntax() for w in self.wffs])
        return res

    def __hash__(self):
        return hash(self.mm) ^ hash(self.subpfs)

    def elimhyp(self, h):
        """Eliminate the hypothesis with mm h from the proof of this
        theorem"""

        if h not in self.hyps:
            return MP(ImpTC(WffVar(h),self.result), self)
        else:
            return self._elimhyp(h)

    def as_drule(self):
        """Return a representation of self as a D-rule style proof"""

        return self.drule.format(*[p.as_drule() for p in self.subpfs])

class Hyp(Proof):
    """Represent a hypothesis in a proof"""

    drule = '?'

    def __init__(self, mm, value):
        self.mm = mm
        if value:
            Proof.__init__(self, (), (WffVar(mm),))
        else:
            Proof.__init__(self, (), (Not(WffVar(mm)),))

    def __str__(self):
        return 'w' + self.mm

    def _hypsof(self):
        return {self.mm}

    def _elimhyp(self, h):
        return Identity(self.wffs[0])

    def _result(self, w): return w

class Theorem(Proof):
    """Base class to represent a theorem in a proof"""

    def __init__(self, *syntax):
        Proof.__init__(self, (), syntax)

    def _hypsof(self):
        return set()

class MP(Proof):
    """Represent an invocation of Modus Ponens"""

    mm = 'ax-mp'
    drule = 'D{0}{1}'

    def __init__(self, major, minor):
        Proof.__init__(self, (major, minor),
                       (minor.result, major.result.subwffs[1]))

    def __str__(self):
        major, minor = self.subpfs
        ant, con = self.wffs

        return '{} {} {!s} {!s} ax-mp'.format(ant.as_syntax(), con.as_syntax(),
                                              minor, major)

    def _elimhyp(self, h):
        major, minor = self.subpfs

        if h not in major.hyps and isinstance(minor, Hyp) and minor.mm == h:
            return major

        else:
            major_elim = major.elimhyp(h)
            minor_elim = minor.elimhyp(h)
            ant2, con = self.wffs

            if (h in major.hyps and h in minor.hyps) or not USE_ABRVS:
                ant = major_elim.result.subwffs[0]
                return MP(MP(ImpDist(ant,ant2,con), major_elim), minor_elim)
            elif h in minor.hyps:
                ant = minor_elim.result.subwffs[0]
                return MP(MP(ImIm2(ant2,con,ant), major), minor_elim)
            elif h in major.hyps:
                ant = major_elim.result.subwffs[0]
                return MP(MP(Com12(ant,ant2,con),major_elim), minor)

    def _result(self, w1, w2):
        return w2

class ImpTC(Theorem):
    mm = '{} {} ax-1'
    drule = '1'

    def _result(self, w1, w2): return Imp(w1,Imp(w2,w1))

class ImpDist(Theorem):
    mm = '{} {} {} ax-2'
    drule = '2'

    def _result(self, w1, w2, w3):
        return Imp(Imp(w1,Imp(w2,w3)),Imp(Imp(w1,w2),Imp(w1,w3)))

class ImpFA(Theorem):
    mm = '{} {} pm2.21'
    drule = 'DD2D131'

    def _result(self, w1, w2): return Imp(Not(w1),Imp(w1,w2))

class ImpTAFC(Theorem):
    mm = '{} {} mth8'
    drule = 'DD2D13DD2D1D2D1D3DD2DD2D13DD2D1311DD2D1D2DD2DD2D13DD2D13111'

    def _result(self, w1, w2):
        return Imp(w1,Imp(Not(w2),Not(Imp(w1,w2))))

class Identity(Theorem):
    mm = '{} id'
    drule = 'DD211'

    def _result(self, w): return Imp(w,w)

class DNAdd(Theorem):
    mm = '{} notnot'
    drule = 'D3DD2DD2D13DD2D1311'

    def _result(self, w): return Imp(w,Not(Not(w)))

class Inev(Theorem):
    mm = '{} {} pm2.61'
    drule = 'DD2D1D2D1DD2DD2D13D2DD2D1311DD2D1DD2DD2D121D1DD2D13D2D1D3DD2DD2D13DD2D1311DD2D121'

    def _result(self, w1, w2):
        return Imp(Imp(w1,w2),Imp(Imp(Not(w1),w2),w2))

class ImIm2(Theorem):
    mm = '{} {} {} imim2'
    drule = 'DD2D121'

    def _result(self, w1, w2, w3):
        return Imp(Imp(w1,w2),Imp(Imp(w3,w1),Imp(w3,w2)))

class Com12(Theorem):
    mm = '{} {} {} pm2.04'
    drule = 'DD2D1DD22D11DD2D112'

    def _result(self, w1, w2, w3):
        return Imp(Imp(w1,Imp(w2,w3)),Imp(w2,Imp(w1,w3)))

class Con3(Theorem):
    mm = '{} {} con3'
    drule = 'DD2D1DD2D13DD2D1DD22D2DD2D13DD2D1311D2D1D3DD2DD2D13DD2D1311'

    def _result(self, w1, w2):
        return Imp(Imp(w1,w2),Imp(Not(w2),Not(w1)))

class BiImp1(Theorem):
    mm = '{} {} biimp'
    drule = 'DD2D1D3DD2D1D3DD2DD2D13DD2D1311DD2D131DD3DD2D1D3D1BDD2D1311'

    def _result(self, w1, w2):
        return Imp(Iff(w1,w2),Imp(w1,w2))

class BiImp2(Theorem):
    mm = '{} {} biimpr'
    drule = 'DD2D1D3DD2D1D3DD2DD2D13DD2D13111DD3DD2D1D3D1BDD2D1311'

    def _result(self, w1, w2):
        return Imp(Iff(w1,w2),Imp(w2,w1))

class Tru(Theorem):
    mm = 'tru'
    drule = 'DDD3DD2D1D3D1DDD3DD2D1D3D1BDD2D1311t11DDD3DD2D1D3D1B11DD3DD2DD2DD2D13DD2D1311D1DD211DD211'

    def _result(self):
        return WTru()

class DefOr(Theorem):
    mm = '{} {} df-or'
    drule = 'A'

    def _result(self, w1, w2):
        return Iff(Or(w1,w2),Imp(Not(w1),w2))

class DefAnd(Theorem):
    mm = '{} {} df-an'
    drule = 'K'

    def _result(self, w1, w2):
        return Iff(And(w1,w2),Not(Imp(w1,Not(w2))))

class DefBi(Theorem):
    mm = '{} {} dfbi1'
    drule = 'DDD3DD2D1D3D1B11B'

    def _result(self, w1, w2):
        return Iff(Iff(w1,w2),Not(Imp(Imp(w1,w2),Not(Imp(w2,w1)))))

class DefThreeAnd(Theorem):
    mm = '{} {} {} df-3an'
    drule = 'k'

    def _result(self, w1, w2, w3):
        return Iff(ThreeAnd(w1,w2,w3),And(And(w1,w2),w3))

class DefThreeOr(Theorem):
    mm = '{} {} {} df-3or'
    drule = 'a'

    def _result(self, w1, w2, w3):
        return Iff(ThreeOr(w1,w2,w3),Or(Or(w1,w2),w3))

class DefNand(Theorem):
    mm = '{} {} df-nand'
    drule = 'd'

    def _result(self, w1, w2):
        return Iff(Nand(w1,w2),Not(And(w1,w2)))

class DefFal(Theorem):
    mm = 'df-fal'
    drule = 'f'

    def _result(self):
        return Iff(WFal(), Not(WTru()))

### Syntax classes ###

class Wff:
    """Base class for well-formed formulas"""

    def __init__(self, subwffs):
        self.subwffs = tuple(subwffs)
        varsof = set()
        for w in subwffs:
            varsof.update(w.varsof)
        self.varsof = frozenset(varsof)

    def eval_subwffs_under(self, var_assignment):
        """Compute the truth value of each sub-wff under var_assignment"""

        return tuple([w.eval_under(var_assignment) for w in self.subwffs])

    def eval_under(self, var_assignment):
        """Compute the value of self under var_assignment"""

        NotImplemented

    def prove_subwff_under(self, var_assignment, i):
        """Prove the i-th subwff of self under var_assignment"""

        w = self.subwffs[i]
        return w.prove_under(var_assignment)

    def prove_under(self, var_assignment):
        """Return a proof of self if self is true under var_assignment,
        and a proof of -. self if self is false under var_assignment"""

        NotImplemented

    def as_syntax(self):
        """Return the syntax proof of self"""

        return self.syntax.format(*[w.as_syntax() for w in self.subwffs])

    def __str__(self):
        return self.label.format(*[str(w) for w in self.subwffs])

class Unknown(Wff):
    label = '?'
    syntax = '?'

    def __init__(self):
        Wff.__init__(self, ())

class WffVar(Wff):
    """Represent a wff variable"""

    def __init__(self, name):
        Wff.__init__(self, ())
        self.label = name
        self.syntax = 'w' + name
        self.varsof = frozenset([name])

    def eval_under(self, var_assignment):
        return var_assignment[self.label]

    def prove_under(self, var_assignment):
        return Hyp(self.label, var_assignment[self.label])

class DerivedWff(Wff):
    """Represent a wff defined in terms of another wff"""

    def prove_under(self, var_assignment):
        df_obj = self.df(*self.subwffs)
        prim = df_obj.result.subwffs[1]
        prim_pf = prim.prove_under(var_assignment)

        if self.eval_under(var_assignment):
            return MP(MP(BiImp2(self, prim), df_obj), prim_pf)
        else:
            return MP(MP(Con3(self,prim),MP(BiImp1(self,prim),df_obj)),prim_pf)

class BinaryConn(Wff):
    """Represent a binary connective"""

    def __init__(self, w1, w2):
        Wff.__init__(self, (w1, w2))

class TrinaryConn(Wff):
    """Represent a trinary connective"""

    def __init__(self, w1, w2, w3):
        Wff.__init__(self, (w1, w2, w3))

class Imp(BinaryConn):
    """Represent logical implication"""

    label = "( {0} -> {1} )"
    syntax = '{0} {1} wi'

    def eval_under(self, var_assignment):
        b1, b2 = self.eval_subwffs_under(var_assignment)
        return not b1 or b2

    def prove_under(self, var_assignment):
        b1, b2 = self.eval_subwffs_under(var_assignment)
        p1 = self.prove_subwff_under(var_assignment, 0)
        p2 = self.prove_subwff_under(var_assignment, 1)
        w1, w2 = self.subwffs

        if not b1:
            return MP(ImpFA(w1, w2), p1)
        elif b2:
            return MP(ImpTC(w2, w1), p2)
        else:
            return MP(MP(ImpTAFC(w1, w2), p1), p2)

class Not(Wff):
    """Represent logical negation"""

    label = "-. {0}"
    syntax = '{0} wn'

    def __init__(self, w):
        Wff.__init__(self, (w,))

    def eval_under(self, var_assignment):
        return not self.eval_subwffs_under(var_assignment)[0]

    def prove_under(self, var_assignment):
        b1, = self.eval_subwffs_under(var_assignment)
        p1 = self.prove_subwff_under(var_assignment, 0)

        if b1:
            return MP(DNAdd(self.subwffs[0]), p1)
        else:
            return p1

class And(BinaryConn, DerivedWff):
    """Represent logical conjunction"""

    label = r"( {0} /\ {1} )"
    syntax = '{0} {1} wa'
    df = DefAnd

    def eval_under(self, var_assignment):
        b1, b2 = self.eval_subwffs_under(var_assignment)
        return b1 and b2

class Or(BinaryConn, DerivedWff):
    """Represent logical disjunction"""

    label = r"( {0} \/ {1} )"
    syntax = '{0} {1} wo'
    df = DefOr

    def eval_under(self, var_assignment):
        b1, b2 = self.eval_subwffs_under(var_assignment)
        return b1 or b2

class Iff(BinaryConn, DerivedWff):
    """Represent logical equivalence"""

    label = "( {0} <-> {1} )"
    syntax = '{0} {1} wb'
    df = DefBi

    def eval_under(self, var_assignment):
        b1, b2 = self.eval_subwffs_under(var_assignment)

        return b1 == b2

class Nand(BinaryConn, DerivedWff):
    """Represent Scheffer stroke"""

    label = r"( {0} -/\ {1} )"
    syntax = '{0} {1} wnand'
    df = DefNand

    def eval_under(self, var_assignment):
        b1, b2 = self.eval_subwffs_under(var_assignment)
        return not (b1 and b2)


class ThreeAnd(TrinaryConn, DerivedWff):
    """Represent triple conjunction"""

    label = r"( {0} /\ {1} /\ {2} )"
    syntax = '{0} {1} {2} w3a'
    df = DefThreeAnd

    def eval_under(self, var_assignment):
        return all(self.eval_subwffs_under(var_assignment))

class ThreeOr(TrinaryConn, DerivedWff):
    """Represent triple disjunction"""

    label = r"( {0} \/ {1} \/ {2} )"
    syntax = '{0} {1} {2} w3o'
    df = DefThreeOr

    def eval_under(self, var_assignment):
        return any(self.eval_subwffs_under(var_assignment))

class LogicalConst(Wff):
    """Represent a logical constant"""

    def __init__(self):
        Wff.__init__(self, ())

class WTru(LogicalConst):
    """Represent logical true"""

    label = 'T.'
    syntax = 'wtru'

    def eval_under(self, asgn):
        return True

    def prove_under(self, asgn):
        return Tru()

class WFal(LogicalConst, DerivedWff):
    """Represent logical false"""

    label = 'F.'
    syntax = 'wfal'
    df = DefFal

    def eval_under(self, asgn):
        return False

### Proof mechanism ###

def prove(wff):
    """Prove the tautology wff"""

    varsof = list(wff.varsof)

    def p(vs, asgns):
        if vs:
            v = vs[0]
            truedict = asgns.copy()
            truedict[v] = True
            truep = p(vs[1:], truedict).elimhyp(v)
            if isinstance(truep, MP) and isinstance(truep.subpfs[0], ImpTC):
                return truep.subpfs[1]

            falsedict = asgns.copy()
            falsedict[v] = False
            falsep = p(vs[1:], falsedict).elimhyp(v)
            if isinstance(falsep, MP) and isinstance(falsep.subpfs[0], ImpTC):
              return falsep.subpfs[1]

            return MP(MP(Inev(WffVar(v),wff),truep),falsep)
        else:
            if not wff.eval_under(asgns):
                raise ValueError('{0:s} is not true under {1:s}'
                                 .format(wff,asgns))

            return wff.prove_under(asgns)

    return p(varsof, {})

### Parser functions ###

class ParseError(Exception): pass

class MMParser:
    def __init__(self, toks):
        toks.reverse()
        self.toks = toks

    def parse(self):
        if not self.toks:
            raise ParseError('Stack underflow')
        else:
            tok = self.toks.pop()
            if tok == '-.':
                return Not(self.parse())
            elif tok.isalpha():
                return WffVar(tok)
            elif tok == 'T.':
                return WTru()
            elif tok == 'F.':
                return WFal()
            elif tok == '(':
                return self.parseparen()
            else:
                raise ParseError('Invalid character ' + tok)

    def parseparen(self):
        wcls = None
        subwffs = [self.parse()]
        tok = self.toks.pop()
        subwffs.append(self.parse())
        
        if tok == '->':
            wcls = Imp
        elif tok == '-/\\':
            wcls = Nand
        elif tok == '<->':
            wcls = Iff
        elif tok == r'\/':
            if self.toks[-1] == r'\/':
                self.toks.pop()
                wcls = ThreeOr
                subwffs.append(self.parse())
            else:
                wcls = Or
        elif tok == '/\\':
            if self.toks[-1] == '/\\':
                self.toks.pop()
                wcls = ThreeAnd
                subwffs.append(self.parse())
            else:
                wcls = And
        else:
            raise ParseError('Invalid token: ' + tok)

        if self.toks.pop() != ')':
            raise ParseError('Unterminated parenthesis')
        return wcls(*subwffs)

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print('usage:', sys.argv[0], '[-d|label] [wff]', file=sys.stderr)
        sys.exit(1)

    label = sys.argv[1]
    wff_str = sys.argv[2]
    wff = MMParser(wff_str.split()).parse()
    if sys.argv[1] == '-d':
        USE_ABRVS = False
        pf = prove(wff)
        print(pf.as_drule())
    else:
        pf = prove(wff)
        print(sys.argv[1], '$p |-', wff, '$=', pf, '$.')
